# -*- coding: utf-8 -*-
"""MT_Keywords_nonconformity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14aTEwIEbU1JrwDijNf2iGndPbfX126hM

#Exploratory Data Analysis
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.utils import resample
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import classification_report

from sklearn.preprocessing import LabelEncoder

from sklearn.metrics import roc_curve, auc

dataset = pd.read_csv('mtsamples.csv')
dataset.drop(dataset.columns[[0]],axis=1)

dataset.head(5)

print(len(dataset))

dataset['medical_specialty'].unique()

len(dataset['medical_specialty'].unique())

freq_table = dataset['medical_specialty'].value_counts().nlargest(7)

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

freq_table = dataset['medical_specialty'].value_counts()

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

#df_keepkeywords for all the rows in the datset
df_keepkeywords_all = dataset.drop(dataset.columns[[0, 1, 3,4]], axis=1)
df_keepkeywords_all

# Get the column to shift
col_to_shift = df_keepkeywords_all['medical_specialty']
# Drop the column from its current position
df_keepkeywords_all = df_keepkeywords_all.drop('medical_specialty', axis=1)
# Insert the column at a new position
new_position = 1  # set the new position of the column
df_keepkeywords_all.insert(new_position, 'medical_specialty', col_to_shift)
df_keepkeywords_all.head(5)

df_keepkeywords_all.head(5)

"""#Check for missing values
 1. Drop rows which contain ```nan``` values
 2. Replace the values in ```medical_specialty``` with values ```8``` and above with ```8```
 * Intuition: Here the value ```8``` represents ```others```
"""

df_keepkeywords_all.isnull().any()
# There are some rows where keyword contained is NaN
#So, dropping the rows which contain Null values in keywords

df_keepkeywords_all=df_keepkeywords_all.dropna()
df_keepkeywords_all=df_keepkeywords_all.reset_index(drop=True)

df_keepkeywords_all

# Get the column with string labels
label_col =  df_keepkeywords_all['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepkeywords_all['medical_specialty'] = label_encoded

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

freq_table = df_keepkeywords_all['medical_specialty'].value_counts().nlargest(7)

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

"""The Top 7 medical specialties are:
Here EV stands for encoded value which we get after using the Label Encoder



EV  Medical Specialty    

27 Surgery  

4 Consult- History and Phy.

2 Cardiovascular/ Pulmonary 

14 General Medicine

13 Gastroenterology

21 Neurology

23 Obstetrics/ Gynecology

Replacing the vaues 8 and above in ```medical_specialty``` with 8
"""

df_keepkeywords_all['medical_specialty'] = df_keepkeywords_all['medical_specialty'].apply(lambda x: 8 if x not in [27,4,2,14,13,21,23] else x)

# Get the column with string labels
label_col =  df_keepkeywords_all['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepkeywords_all['medical_specialty'] = label_encoded

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

"""So the mapping becomes:
```{2: 0, 4: 1, 8: 2, 13: 3, 14: 4, 21: 5, 23: 6, 27: 7}```

Which means:
```
0- Cardiovascular/ Pulmonary
1- Consult- History and Phy.
2- Others
3- Gastroenterology
4- General Medicine
5- Neurology
6- Obstetrics/ Gynecology
7- Surgery
```

# Checking the composition of the dataset
"""

freq_table = df_keepkeywords_all['medical_specialty'].value_counts()

freq_table.plot(kind='bar')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

df_keepkeywords_all.to_csv('df_keepkeywords_all.csv', index=True)

"""#Text Cleaning and Preprocessing"""

df_keepkeywords = pd.read_csv('df_keepkeywords_all.csv')

import re
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
corpus = []
df_keepkeywords['keywords'] = df_keepkeywords['keywords'].astype(str)
for i in range(0, len(df_keepkeywords)):
  keyword = re.sub('[^a-zA-Z]', ' ', df_keepkeywords['keywords'][i])
  keyword = keyword.lower()
  keyword = keyword.split()
  ps = PorterStemmer()
  all_stopwords = stopwords.words('english')
  all_stopwords.remove('not')
  keyword = [ps.stem(word) for word in keyword if not word in set(all_stopwords)]
  keyword = ' '.join(keyword)
  corpus.append(keyword)

"""#Encoding the Dependent Variable- ```medical_specialty```"""

from sklearn.preprocessing import LabelEncoder

# Get the column with string labels
label_col =  df_keepkeywords['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepkeywords['medical_specialty'] = label_encoded

"""Get the Mapping"""

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

df_keepkeywords

"""#Creating Bag of Words Model"""

df_keepkeywords

from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features = 150)
X = cv.fit_transform(corpus).toarray()
y =  df_keepkeywords.iloc[:, -1].values

"""## Splitting the dataset into the Training set and Test set"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test_MNB = train_test_split(X, y, test_size = 0.20, random_state = 0)

# Resample the dataset
X_train_resampled, y_train_resampled = resample(X_train, y_train, stratify=y_train, random_state=42)

"""# Training the  Multinomial Naive Bayes model on the Training set"""

# Train the classifier
clf = MultinomialNB()
clf.fit(X_train_resampled, y_train_resampled)

"""# Evaluate Multinomial Naive Bayes classifier"""

# Evaluate the classifier
y_pred_MNB = clf.predict(X_test)
print(classification_report(y_test_MNB, y_pred_MNB))

"""#Creating a Confusion Matrix after using Multinomial NB"""

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test_MNB, y_pred_MNB)
print(cm)
accuracy_score(y_test_MNB, y_pred_MNB)

"""# Running a Naive Bayes Classifier"""

from sklearn.naive_bayes import GaussianNB
classifier = GaussianNB()
classifier.fit(X_train, y_train)

"""# Evaluate Naive Bayes Classifier"""

# Evaluate the classifier
y_pred_NB = classifier.predict(X_test)
#Assisgn the y_test_MNB to y_test_NB
y_test_NB=y_test_MNB
print(classification_report(y_test_NB, y_pred_NB))

"""#Creating the Confusion Matrix after using Naive Bayes Classifier"""

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test_NB, y_pred_NB)
print(cm)
accuracy_score(y_test_NB, y_pred_NB)

"""#Using Non Conformist + Classifier"""

!pip install nonconformist

from nonconformist.evaluation import class_mean_errors

from nonconformist.nc import ClassifierNc

from nonconformist.cp import IcpClassifier
from nonconformist.nc import NcFactory
from nonconformist.base import ClassifierAdapter
from nonconformist.nc import ClassifierNc, MarginErrFunc

from tabulate import tabulate   # Import tabulate function for tabular formatting

# Divide the data into proper training set, calibration set and test set
X_train_cal, X_test, y_train_cal, y_test = train_test_split(
    X, y, test_size=0.2
)
X_train, X_cal, y_train, y_cal = train_test_split(
    X_train_cal, y_train_cal, test_size=0.25
)

# Create an inductive conformal classifier
icp = IcpClassifier(ClassifierNc(ClassifierAdapter(MultinomialNB()),MarginErrFunc()))
# Fit the ICP using the proper training set
icp.fit(X_train, y_train)
# Calibrate the ICP using the calibration set
icp.calibrate(X_cal, y_cal)

"""# There are a total of 8 labels

```
0- Cardiovascular/ Pulmonary
1- Consult- History and Phy.
2- Others
3- Gastroenterology
4- General Medicine
5- Neurology
6- Obstetrics/ Gynecology
7- Surgery
```
"""

prediction = icp.predict(X_test, significance=0.1)

predictions = icp.predict_conf(X_test)
confidence = predictions[:, 1].round(3)
credibility = predictions[:, 2].round(3)

y_pred = predictions[:, 0].astype(int)

header = np.array(['c0-label', 'c1-label', 'c2-label','c3-label','c4-label','c5-label','c6-label','c7-label',
                   'c0-value', 'c1-value','c2-value','c3-value','c4-value','c5-value','c6-value','c7-value', 
                   'conf', 'cred', 'y-test','y-pred'])

label_map = {0: 'Cardiovascular/ Pulmonary', 1: 'Consult- History and Phy.', 2: 'Others', 3: 'Gastroenterology', 4: 'General Medicine', 5: 'Neurology', 6: 'Obstetrics/ Gynecology', 7: 'Surgery'}
# Define a function that maps integer labels to categorical names using the label_map
label_mapper = np.vectorize(lambda label: label_map[label])
# Use the label_mapper function to map the integer labels in y to categorical names
prediction_categorical = label_mapper(prediction)
y_label_names = label_mapper(y_pred)

table = np.vstack([prediction_categorical.T, prediction.T, confidence, credibility, y_label_names, y_pred]).T

df = pd.DataFrame(np.vstack([header, table]))
print(df)

prediction

print(df.to_string(index=False, header=False))

"""```
label_map = {0: 'Cardiovascular/ Pulmonary', 1: 'Consult- History and Phy.', 2: 'Others', 3: 'Gastroenterology', 4: 'General Medicine', 5: 'Neurology', 6: 'Obstetrics/ Gynecology', 7: 'Surgery'}

```
"""

cardio_count = 0
consult_count = 0
others_count = 0
gastro_count = 0
genmed_count = 0
neuro_count = 0
gynec_count=0
surgery_count=0

# Loop over each predicted label and update the corresponding counter
for label in y_label_names:
    if label == 'Cardiovascular/ Pulmonary':
        cardio_count += 1
    elif label == 'Consult- History and Phy.':
        consult_count += 1
    elif label == 'Others':
        others_count += 1
    elif label == 'Gastroenterology':
        gastro_count += 1
    elif label == 'General Medicine':
        genmed_count += 1    
    elif label == 'Neurology':
        neuro_count += 1
    elif label == 'Obstetrics/ Gynecology':
        gynec_count += 1
    elif label == 'Surgery':
        surgery_count += 1

# Print the results
print(f'Cardiovascular/ Pulmonary: {cardio_count}')
print(f'Consult- History and Phy.: {consult_count}')
print(f'Others: {others_count}')
print(f'Gastroenterology: {gastro_count}')
print(f'General Medicine: {genmed_count}')
print(f'Neurology: {neuro_count}')
print(f'Obstetrics/ Gynecology count: {gynec_count}')
print(f'Surgery count: {surgery_count}')

error_rate1 = class_mean_errors(icp.predict(X_test), y_test, significance=0.1)
print('Error rate 1: {}'.format(error_rate1))


error_rate2 = class_mean_errors(icp.predict(X_test), y_test, significance=0.2)
print('Error rate 2: {}'.format(error_rate2))


error_rate3 = class_mean_errors(icp.predict(X_test), y_test, significance=0.6)
print('Error rate 3: {}'.format(error_rate3))



error_rate4 = class_mean_errors(icp.predict(X_test), y_test, significance=0.8)
print('Error rate 4: {}'.format(error_rate4))

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

# Predict confidence and credibility
predictions = icp.predict_conf(X_test)
confidence = predictions[:, 1]
credibility = predictions[:, 2]

# Plot credibility
plt.figure(figsize=(8, 6))
plt.scatter(confidence,credibility)
plt.xscale("log")

plt.xlabel('Cconfidence')
plt.ylabel('Credibility')
plt.title('Confidence Credibility Distribution')
plt.show()

"""Create a map with keys being the encoded values and values being the medical speciality"""

medical_specialty = {
0: 'Cardiovascular/ Pulmonary',
1: 'Consult- History and Phy.',
2: 'Others',
3: 'Gastroenterology',
4: 'General Medicine',
5: 'Neurology',
6: 'Obstetrics/ Gynecology',
7: 'Surgery'
}

# Produce nonconformity scores for the test set
nc_scores = icp.predict(X_test, significance=0.20)

# Obtain a set prediction for the test set
set_prediction = icp.predict(X_test, significance=None)

# Tabulate the nc_scores, set_prediction, and predicted label values side by side
table = []
for i, (nc_score, set_pred) in enumerate(zip(nc_scores, set_prediction)):
    predicted_label = medical_specialty[np.argmax(set_pred)]
    table.append([i+1, nc_score, set_pred, predicted_label])

headers = ['Instance', 'nc_score', 'set_prediction', 'predicted_label']
print(tabulate(table, headers=headers))