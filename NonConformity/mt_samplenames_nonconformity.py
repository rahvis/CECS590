# -*- coding: utf-8 -*-
"""MT_SampleNames_nonconformity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LQ_1hXI64yTH9zEwOp73ummBtzii9rxd

#Exploratory Data Analysis
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.utils import resample
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import classification_report

from sklearn.preprocessing import LabelEncoder

dataset = pd.read_csv('mtsamples.csv')

dataset.head(5)

dataset=dataset.drop(dataset.columns[[0,1,4,5]],axis=1)
dataset.head(5)

print(len(dataset))

dataset['medical_specialty'].unique()

len(dataset['medical_specialty'].unique())

freq_table = dataset['medical_specialty'].value_counts().nlargest(7)

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

freq_table = dataset['medical_specialty'].value_counts()

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

df_keepsample_all=dataset
df_keepsample_all

# Get the column to shift
col_to_shift = df_keepsample_all['medical_specialty']
# Drop the column from its current position
df_keepsample_all = df_keepsample_all.drop('medical_specialty', axis=1)
# Insert the column at a new position
new_position = 1  # set the new position of the column
df_keepsample_all.insert(new_position, 'medical_specialty', col_to_shift)
df_keepsample_all.head(5)

"""#Check for missing values
 1. Drop rows which contain ```nan``` values
 2. Replace the values in ```medical_specialty``` with values ```8``` and above with ```8```
 * Intuition: Here the value ```8``` represents ```others```
"""

df_keepsample_all.isnull().any()
# There are some rows where keyword contained is NaN
#So, dropping the rows which contain Null values in keywords

# Get the column with string labels
label_col =  df_keepsample_all['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepsample_all['medical_specialty'] = label_encoded

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

freq_table = df_keepsample_all['medical_specialty'].value_counts().nlargest(7)

freq_table.plot(kind='pie')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

"""The Top 7 medical specialties are:
Here EV stands for encoded value which we get after using the Label Encoder



EV  Medical Specialty    

27 Orthopedic  

5 Consult- History and Phy.

3 Cardiovascular/ Pulmonary 

15 General Medicine

14 Gastroenterology

38 Surgery

33 Radiology

Replacing the vaues 8 and above in ```medical_specialty``` with 8
"""

df_keepsample_all['medical_specialty'] = df_keepsample_all['medical_specialty'].apply(lambda x: 8 if x not in [38,5,3,27,33,15,14] else x)

# Get the column with string labels
label_col =  df_keepsample_all['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepsample_all['medical_specialty'] = label_encoded

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

"""So the mapping becomes:
```{3: 0, 5: 1, 8: 2, 14: 3, 15: 4, 27: 5, 33: 6, 38: 7}```

Which means:
```
0- Cardiovascular/ Pulmonary
1- Consult- History and Phy.
2- Others
3- Gastroenterology
4- General Medicine
5- Orthopedic
6- Radiology
7- Surgery
```

# Checking the composition of the dataset
"""

freq_table = df_keepsample_all['medical_specialty'].value_counts()

freq_table.plot(kind='bar')

plt.title('Frequency Distribution of medical_specialty')
plt.xlabel('medical_specialty')
plt.ylabel('Frequency')

plt.xticks(rotation=90)

plt.tight_layout()
plt.show()

df_keepsample_all.to_csv('df_keepsample_all.csv', index=True)

"""#Text Cleaning and Preprocessing"""

df_keepsample = pd.read_csv('df_keepsample_all.csv')

import re
import nltk
nltk.download('stopwords')
from nltk.corpus import stopwords
from nltk.stem.porter import PorterStemmer
corpus = []
df_keepsample['sample_name'] = df_keepsample['sample_name'].astype(str)
for i in range(0, len(df_keepsample)):
  sample_name = re.sub('[^a-zA-Z]', ' ', df_keepsample['sample_name'][i])
  sample_name = sample_name.lower()
  sample_name = sample_name.split()
  ps = PorterStemmer()
  all_stopwords = stopwords.words('english')
  all_stopwords.remove('not')
  sample_name = [ps.stem(sn) for sn in sample_name if not sn in set(all_stopwords)]
  sample_name = ' '.join(sample_name)
  corpus.append(sample_name)

"""#Encoding the Dependent Variable- ```medical_specialty```"""

from sklearn.preprocessing import LabelEncoder

# Get the column with string labels
label_col = df_keepsample['medical_specialty']

# Initialize a LabelEncoder object
label_encoder = LabelEncoder()

# Fit and transform the label column
label_encoded = label_encoder.fit_transform(label_col)

# Replace the string column with the encoded column
df_keepsample['medical_specialty'] = label_encoded

"""Get the Mapping"""

# Get the mapping of string labels to integer labels
label_mapping = dict(zip(label_encoder.classes_, range(len(label_encoder.classes_))))

# Print the mapping
print(label_mapping)

"""#Creating Bag of Words Model"""

from sklearn.feature_extraction.text import CountVectorizer
cv = CountVectorizer(max_features = 150)
X = cv.fit_transform(corpus).toarray()
y = df_keepsample.iloc[:, -1].values

"""## Splitting the dataset into the Training set and Test set"""

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.20, random_state = 0)

# Resample the dataset
X_train_resampled, y_train_resampled = resample(X_train, y_train, stratify=y_train, random_state=42)

"""# Training the  Multinomial Naive Bayes model on the Training set"""

# Train the classifier
clf = MultinomialNB()
clf.fit(X_train_resampled, y_train_resampled)

"""# Evaluate Multinomial Naive Bayes classifier"""

# Evaluate the classifier
y_pred = clf.predict(X_test)
print(classification_report(y_test, y_pred))

"""#Creating a Confusion Matrix after using Multinomial NB"""

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test, y_pred)
print(cm)
accuracy_score(y_test, y_pred)

"""# Running a Naive Bayes Classifier"""

from sklearn.naive_bayes import GaussianNB
classifier = GaussianNB()
classifier.fit(X_train, y_train)

"""# Evaluate Naive Bayes Classifier"""

# Evaluate the classifier
y_pred = classifier.predict(X_test)
print(classification_report(y_test, y_pred))

"""#Creating the Confusion Matrix after using Naive Bayes Classifier"""

from sklearn.metrics import confusion_matrix, accuracy_score
cm = confusion_matrix(y_test, y_pred)
print(cm)
accuracy_score(y_test, y_pred)

"""#Using Non Conformist + Classifier"""

!pip install nonconformist

from nonconformist.evaluation import class_mean_errors

from nonconformist.nc import ClassifierNc

from nonconformist.cp import IcpClassifier
from nonconformist.nc import NcFactory
from nonconformist.base import ClassifierAdapter
from nonconformist.nc import ClassifierNc, MarginErrFunc

from tabulate import tabulate   # Import tabulate function for tabular formatting

# Divide the data into proper training set, calibration set and test set
X_train_cal, X_test, y_train_cal, y_test = train_test_split(
    X, y, test_size=0.2
)
X_train, X_cal, y_train, y_cal = train_test_split(
    X_train_cal, y_train_cal, test_size=0.25
)

# Create an inductive conformal classifier
icp = IcpClassifier(ClassifierNc(ClassifierAdapter(MultinomialNB()),MarginErrFunc()))
# Fit the ICP using the proper training set
icp.fit(X_train, y_train)
# Calibrate the ICP using the calibration set
icp.calibrate(X_cal, y_cal)

"""# There are a total of 8 labels

```
0- Cardiovascular/ Pulmonary
1- Consult- History and Phy.
2- Others
3- Gastroenterology
4- General Medicine
5- Orthopedic
6- Radiology
7- Surgery
```
"""

prediction = icp.predict(X_test, significance=0.1)

predictions = icp.predict_conf(X_test)
confidence = predictions[:, 1].round(3)
credibility = predictions[:, 2].round(3)

y_pred = predictions[:, 0].astype(int)

header = np.array(['c0-label', 'c1-label', 'c2-label','c3-label','c4-label','c5-label','c6-label','c7-label',
                   'c0-value', 'c1-value','c2-value','c3-value','c4-value','c5-value','c6-value','c7-value', 
                   'conf', 'cred', 'y-test','y-pred'])

label_map = {0: 'Cardiovascular/ Pulmonary', 1: 'Consult- History and Phy.', 2: 'Others', 3: 'Gastroenterology', 4: 'General Medicine', 5: 'Orthopedic', 6: 'Radiology', 7: 'Surgery'}
# Define a function that maps integer labels to categorical names using the label_map
label_mapper = np.vectorize(lambda label: label_map[label])
# Use the label_mapper function to map the integer labels in y to categorical names
prediction_categorical = label_mapper(prediction)
y_label_names = label_mapper(y_pred)

table = np.vstack([prediction_categorical.T, prediction.T, confidence, credibility, y_label_names, y_pred]).T

df = pd.DataFrame(np.vstack([header, table]))
print(df)

prediction

print(df.to_string(index=False, header=False))

"""```

label_map = {0: 'Cardiovascular/ Pulmonary', 1: 'Consult- History and Phy.', 2: 'Others', 3: 'Gastroenterology', 4: 'General Medicine', 5: 'Orthopedic', 6: 'Radiology', 7: 'Surgery'}


```
"""

cardio_count = 0
consult_count = 0
others_count = 0
gastro_count = 0
genmed_count = 0
ortho_count = 0
radio_count=0
surgery_count=0

# Loop over each predicted label and update the corresponding counter
for label in y_label_names:
    if label == 'Cardiovascular/ Pulmonary':
        cardio_count += 1
    elif label == 'Consult- History and Phy.':
        consult_count += 1
    elif label == 'Others':
        others_count += 1
    elif label == 'Gastroenterology':
        gastro_count += 1
    elif label == 'General Medicine':
        genmed_count += 1    
    elif label == 'Orthopedic':
        ortho_count += 1
    elif label == 'Radiology':
        radio_count += 1
    elif label == 'Surgery':
        surgery_count += 1

# Print the results
print(f'Cardiovascular/ Pulmonary: {cardio_count}')
print(f'Consult- History and Phy.: {consult_count}')
print(f'Others: {others_count}')
print(f'Gastroenterology: {gastro_count}')
print(f'General Medicine: {genmed_count}')
print(f'Orthopedics: {ortho_count}')
print(f'Radiology count: {radio_count}')
print(f'Surgery count: {surgery_count}')

error_rate1 = class_mean_errors(icp.predict(X_test), y_test, significance=0.1)
print('Error rate 1: {}'.format(error_rate1))


error_rate2 = class_mean_errors(icp.predict(X_test), y_test, significance=0.2)
print('Error rate 2: {}'.format(error_rate2))


error_rate3 = class_mean_errors(icp.predict(X_test), y_test, significance=0.6)
print('Error rate 3: {}'.format(error_rate3))



error_rate4 = class_mean_errors(icp.predict(X_test), y_test, significance=0.8)
print('Error rate 4: {}'.format(error_rate4))

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

# Predict confidence and credibility
predictions = icp.predict_conf(X_test)
confidence = predictions[:, 1]
credibility = predictions[:, 2]

# Plot credibility
plt.figure(figsize=(8, 6))
plt.scatter(confidence,credibility)
plt.xscale("log")

plt.xlabel('Confidence')
plt.ylabel('Credibility')
plt.title('Confidence Vs Credibility Distribution')
plt.show()

"""Create a map with keys being the encoded values and values being the medical speciality"""

medical_specialty = {0: 'Cardiovascular/ Pulmonary', 1: 'Consult- History and Phy.', 2: 'Others', 3: 'Gastroenterology', 4: 'General Medicine', 5: 'Orthopedic', 6: 'Radiology', 7: 'Surgery'}

# Produce nonconformity scores for the test set
nc_scores = icp.predict(X_test, significance=0.20)

# Obtain a set prediction for the test set
set_prediction = icp.predict(X_test, significance=None)

# Tabulate the nc_scores, set_prediction, and predicted label values side by side
table = []
for i, (nc_score, set_pred) in enumerate(zip(nc_scores, set_prediction)):
    predicted_label = medical_specialty[np.argmax(set_pred)]
    table.append([i+1, nc_score, set_pred, predicted_label])

headers = ['Instance', 'nc_score', 'set_prediction', 'predicted_label']
print(tabulate(table, headers=headers))